#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil tex:t
#+TITLE: MathematicaStan v2.0
#+SUBTITLE: A Mathematica (v11+) package to interact with CmdStan
#+AUTHOR: Picaud Vincent


#+RESULTS:

* Introduction


*MathematicaStan* is a package to interact with [[http://mc-stan.org/interfaces/cmdstan][CmdStan]] from
Mathematica. 

It is developed under *Linux* and is compatible with *Mathematica v11+*

It should work under MacOS and also under Windows but you have to be careful about the way you
enter paths:
- under Linux:
#+BEGIN_EXAMPLE
SetCmdStanDirectory["~/ExternalSoftware/cmdstan-2.19.1"];
#+END_EXAMPLE
- under Windows:
#+BEGIN_EXAMPLE
SetCmdStanDirectory["C:\\Users\\USERNAME\\Documents\\R\\..."; 
#+END_EXAMPLE

*Author & contact:* picaud.vincent at gmail.com

*Windows version:* 
 - Thanks to Jeff Patterson for his contribution (for MathematicaStan v1.0)

** News
*** 2019-06-28 

New MathematicaStan version 2.0!

This version uses Mathematica v11 and has been completely refactored

*Caveat:* breaking changes!

*** 2017-08-01 

The "old" MathematicaStan version based on Mathematica v8.0 is now in
the *v1.0* git branch.

* Installation

** The Stan CmdStan shell interface

First you must install [[http://mc-stan.org/interfaces/cmdstan][CmdStan]]. Once this is done you get a directory containing stuff like:

#+BEGIN_EXAMPLE
bin  doc  examples  Jenkinsfile  LICENSE  make  makefile  README.md  runCmdStanTests.py  src  stan  test-all.sh
#+END_EXAMPLE

With my configuration *CmdStan* is installed in:
#+BEGIN_EXAMPLE
~/ExternalSoftware/cmdstan-2.19.1
#+END_EXAMPLE

For Windows users it is possibly something like:
#+BEGIN_EXAMPLE
C:\\Users\\USER_NAME\\Documents\\R\\cmdstan-?.??.?
#+END_EXAMPLE

** The Mathematica CmdStan package

To install the Mathematica CmdStan package:
- open the =CmdStan.m= file with Mathematica.
- install it using the Mathematica Notebook *File->Install* menu.

** First run

The first time the package is imported
#+BEGIN_SRC mathematica :eval never
<<CmdStan`
#+END_SRC
you will get an error message:
#+BEGIN_EXAMPLE
CmdStan::cmdStanDirectoryNotDefined: CmdStan directory does not exist, use SetCmdStanDirectory[dir] to define it (with something like SetCmdStanDirectory["~/ExternalSoftware/cmdstan-2.19.1"])
#+END_EXAMPLE
This is normal as we must define the Stan StanCmd shell interface root directory. 

With my configuration this is:
#+BEGIN_SRC matheematica :eval never
SetCmdStanDirectory["~/ExternalSoftware/cmdstan-2.19.1"]
#+END_SRC

*Note:* this location is recorded in the =$CmdStanConfigurationFile= file
 and you will not have to redefine it every time you import the
 CmdStan package.


* Tutorial

** Introduction

Import the package as usual

#+BEGIN_SRC mathematica :eval never
<<CmdStan`
#+END_SRC

This package defines these functions (and symbols):

#+BEGIN_SRC mathematica :eval never
?CmdStan`*
#+END_SRC

| CmdStan         | ExportStanData      | GetStanResultMeta | OptimizeDefaultOptions | SetCmdStanDirectory | StanResult                |
| CmdStanVerbose  | GetCmdStanDirectory | ImportStanResult  | RemoveStanOption       | SetStanOption       | VariationalDefaultOptions |
| CompileStanCode | GetStanOption       | MapStanResult     | RunStan                | StanOptionExistsQ   | $CmdStanConfigurationFile |
| ExportStanCode  | GetStanResult       | MapStanResultMeta | SampleDefaultOptions   | StanOptions         |                           |

For this tutorial we use a simple [[https://mc-stan.org/docs/2_19/stan-users-guide/linear-regression.html][linear regression]] example and we will work in a temporary location:

#+BEGIN_SRC mathematica :eval never
SetDirectory[$TemporaryDirectory]
#+END_SRC
#+BEGIN_EXAMPLE
/tmp
#+END_EXAMPLE

** Stan code 

Define the Stan code
#+BEGIN_SRC mathematica :eval never
stancode = "data
  {
    int<lower = 0> N;
    vector[N] x;
    vector[N] y;
  }
  parameters
  {
    real alpha;
    real beta;
    real<lower = 0> sigma;
  }
  model {
    y ~normal(alpha + beta * x, sigma);
  }";
#+END_SRC

and export it

#+BEGIN_SRC mathematica :eval never
stanCodeFile = ExportStanCode["linear_regression.stan", stanCode]
#+END_SRC
#+BEGIN_EXAMPLE
/tmp/linear_regression.stan
#+END_EXAMPLE

** Code compilation

Stan code compilation is performed by 
 #+BEGIN_SRC mathematica :eval never
stanExeFile = CompileStanCode[stanCodeFile] (* Attention: this takes some time *)
 #+END_SRC

With my configuration I get
 #+BEGIN_EXAMPLE
make: Entering directory '/home/picaud/ExternalSoftware/cmdstan-2.19.1'

--- Translating Stan model to C++ code ---
bin/stanc  --o=/tmp/linear_regression.hpp /tmp/linear_regression.stan
Model name=linear_regression_model
Input file=/tmp/linear_regression.stan
Output file=/tmp/linear_regression.hpp
g++ -std=c++1y -pthread -Wno-sign-compare     -O3 -I src -I stan/src -I stan/lib/stan_math/ -I stan/lib/stan_math/lib/eigen_3.3.3 -I stan/lib/stan_math/lib/boost_1.69.0 -I stan/lib/stan_math/lib/sundials_4.1.0/include    -DBOOST_RESULT_OF_USE_TR1 -DBOOST_NO_DECLTYPE -DBOOST_DISABLE_ASSERTS -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION     -c -MT /tmp/linear_regression.o -MT /tmp/linear_regression -include /tmp/linear_regression.hpp -include src/cmdstan/main.cpp -MM -E -MG -MP -MF /tmp/linear_regression.d /tmp/linear_regression.hpp

--- Linking C++ model ---
g++ -std=c++1y -pthread -Wno-sign-compare     -O3 -I src -I stan/src -I stan/lib/stan_math/ -I stan/lib/stan_math/lib/eigen_3.3.3 -I stan/lib/stan_math/lib/boost_1.69.0 -I stan/lib/stan_math/lib/sundials_4.1.0/include    -DBOOST_RESULT_OF_USE_TR1 -DBOOST_NO_DECLTYPE -DBOOST_DISABLE_ASSERTS -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION             -include /tmp/linear_regression.hpp src/cmdstan/main.cpp        stan/lib/stan_math/lib/sundials_4.1.0/lib/libsundials_nvecserial.a stan/lib/stan_math/lib/sundials_4.1.0/lib/libsundials_cvodes.a stan/lib/stan_math/lib/sundials_4.1.0/lib/libsundials_idas.a  -o /tmp/linear_regression
make: Leaving directory '/home/picaud/ExternalSoftware/cmdstan-2.19.1'
 #+END_EXAMPLE

*Note:* if you do not want to have information printed you can use the =StanVerbose= option:

 #+BEGIN_SRC mathematica :eval never
stanExeFile = CompileStanCode[stanCodeFile, StanVerbose -> False]
 #+END_SRC

** Simulate data

Let's simulate some data:
 #+BEGIN_SRC mathematica :eval never
σ = 3; α = 1; β = 2;
n = 20;
X = Range[n];
Y = α + β*x + RandomVariate[NormalDistribution[0, σ], n];
Show[Plot[α + β*x, {x, Min[X], Max[X]}], 
     ListPlot[Transpose@{X, Y}, PlotStyle -> Red]]
 #+END_SRC

[[file:figures/linRegData.png][file:./figures/linRegData.png]]

** Create the =data.R= data file 

The data are stored in a =Association= and then exported thanks to the
=ExportStanData= function.

#+BEGIN_SRC mathematica :eval never
stanData = <|"N" -> n, "x" -> X, "y" -> Y|>;
stanDataFile = ExportStanData[stanExeFile, stanData]
#+END_SRC

#+BEGIN_EXAMPLE
/tmp/linear_regression.data.R
#+END_EXAMPLE

*Note:* this function returns the created file
name =/tmp/linear_regression.data.R=. Its first argument, =stanExeFile=
is simply the Stan executable file name with its path. The
=ExportStanData[]= function modifies the file name extension and
replace it with ".data.R", but you can use it with
any file name:
#+BEGIN_SRC mathematica :eval never
ExportStanData["~/tmp/my_custom_filename.data.R",stanData]
#+END_SRC

** Run Stan, likelihood maximization

We are now able to run the =stanExeFile= executable. 

Let's start by maximizing the likelihood
#+BEGIN_SRC mathematica :eval never
stanResultFile = RunStan[stanExeFile, OptimizeDefaultOptions]
#+END_SRC

#+BEGIN_EXAMPLE
Running: /tmp/linear_regression method=optimize data file=/tmp/linear_regression.data.R output file=/tmp/linear_regression.csv

method = optimize
  optimize
    algorithm = lbfgs (Default)
      lbfgs
        init_alpha = 0.001 (Default)
        tol_obj = 9.9999999999999998e-13 (Default)
        tol_rel_obj = 10000 (Default)
        tol_grad = 1e-08 (Default)
        tol_rel_grad = 10000000 (Default)
        tol_param = 1e-08 (Default)
        history_size = 5 (Default)
    iter = 2000 (Default)
    save_iterations = 0 (Default)
id = 0 (Default)
data
  file = /tmp/linear_regression.data.R
init = 2 (Default)
random
  seed = 2775739062
output
  file = /tmp/linear_regression.csv
  diagnostic_file =  (Default)
  refresh = 100 (Default)

Initial log joint probability = -8459.75
    Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes 
      19      -32.5116    0.00318011    0.00121546      0.9563      0.9563       52   
Optimization terminated normally: 
  Convergence detected: relative gradient magnitude is below tolerance
#+END_EXAMPLE

The =stanResultFile= variable contains now the csv result file:
#+BEGIN_EXAMPLE
/tmp/linear_regression.csv
#+END_EXAMPLE

*Note:* again, if you do not want to have printed output, use the =StanVerbose->False= option.

#+BEGIN_SRC mathematica :eval never
stanResultFile = RunStan[stanExeFile, OptimizeDefaultOptions,StanVerbose->False]
#+END_SRC

*Note:* the method we use is defined by the second argument
=OptimizeDefaultOptions.= If you want to use Variational Bayes or HMC
sampling you must use

#+BEGIN_SRC mathematica :eval never
RunStan[stanExeFile, VariationalDefaultOptions]
#+END_SRC
or
#+BEGIN_SRC mathematica :eval never
RunStan[stanExeFile, SampleDefaultOptions]
#+END_SRC

*Note*: option management will be detailed later in this tutorial.

** Load the CSV result file

To load CSV result file, do

#+BEGIN_SRC mathematica :eval never
stanResult = RunStan[stanResultFile]
#+END_SRC

which prints
#+BEGIN_EXAMPLE
     file: /tmp/linear_regression.csv
     meta: lp__ 
parameter: alpha , beta , sigma 
#+END_EXAMPLE

To access estimated variable α, β and σ, simply do:
#+BEGIN_SRC mathematica :eval never

GetStanResultMeta[stanResult, "lp__"]
αe=GetStanResult[stanResult, "alpha"]
βe=GetStanResult[stanResult, "beta"]
σe=GetStanResult[stanResult, "sigma"]
#+END_SRC

which prints:

#+BEGIN_EXAMPLE
{-32.5116}
{2.51749}
{1.83654}
{3.08191}
#+END_EXAMPLE

*Note*: as with likelihood maximization we only have a point estimation,
the returned values are lists of *one* numbers.

You can plot the estimated line:

#+BEGIN_SRC mathematica :eval never
Show[Plot[{αe + βe*x, α + β*x}, {x, Min[X],Max[X]}, PlotLegends -> "Expressions"], 
     ListPlot[Transpose@{X, Y}, PlotStyle -> Red]]
#+END_SRC

[[file:./figures/linRegEstimate.png]]

** Run Stan, Variational Bayes

We want to solve the same problem but using variational inference. 

As explained before we must use 
#+BEGIN_SRC mathematica :eval never
stanResultFile = RunStan[stanExeFile, VariationalDefaultOptions]
#+END_SRC
instead of 
#+BEGIN_SRC mathematica :eval never
stanResultFile = RunStan[stanExeFile, OptimizeDefaultOptions]
#+END_SRC

Like we do not want to erase our previous result file =stanResultFile=
this is the opportunity to see how options work.

The default options are stored in (the protected) =VariationalDefaultOptions= variable. 

To modify them we must first copy this protected symbol:

#+BEGIN_SRC mathematica :eval never
myOpt=VariationalDefaultOptions
#+END_SRC
prints
#+BEGIN_EXAMPLE
method=variational
#+END_EXAMPLE

For your convenience I remember here the default option values:

#+BEGIN_EXAMPLE
method = variational
  variational
    algorithm = meanfield (Default)
      meanfield
    iter = 10000 (Default)
    grad_samples = 1 (Default)
    elbo_samples = 100 (Default)
    eta = 1 (Default)
    adapt
      engaged = 1 (Default)
      iter = 50 (Default)
    tol_rel_obj = 0.01 (Default)
    eval_elbo = 100 (Default)
    output_samples = 1000 (Default)
id = 0 (Default)
data
  file =  (Default)
init = 2 (Default)
random
  seed = 2784129612
output
  file = output.csv (Default)
  diagnostic_file =  (Default)
  refresh = 100 (Default)
#+END_EXAMPLE

we have to modify ="output file"= option.

This can be done by:
#+BEGIN_SRC mathematica :eval never
myOpt = SetStanOption[myOpt, "output.file", FileNameJoin[{Directory[], "myOutputFile.csv"}]]
#+END_SRC
which prints:
#+BEGIN_EXAMPLE
method=variational output file=/tmp/myOutputFile.csv
#+END_EXAMPLE

*Note*: for each hierarchy use a "." as separator. For instance if you want to modify ="method adapt iter"=, use:
#+BEGIN_SRC mathematica :eval never
myOpt = SetStanOption[myOpt, "method.adapt.iter", 123]
#+END_SRC
which prints
#+BEGIN_EXAMPLE
method=variational adapt iter=123 output file=/tmp/myOutputFile.csv
#+END_EXAMPLE

*Note:*
- to read option value use:
  #+BEGIN_SRC mathematica :eval never
  GetStanOption[myOpt, "method.adapt.iter"]
  #+END_SRC
  which prints
  #+BEGIN_EXAMPLE
  123
  #+END_EXAMPLE
  *Caveat*: if the was not defined (by =SetStanOption=) the function
  returns =$Failed=.

- to erase an option value (and use default value), use:
  #+BEGIN_SRC mathematica :eval never
  myOpt = RemoveStanOption[myOpt, "method.adapt.iter"]
  #+END_SRC
  which prints
  #+BEGIN_EXAMPLE
  method=variational output file=/tmp/myOutputFile.csv
  #+END_EXAMPLE

Now the digression about option is finished. 

We can run Stan:

#+BEGIN_SRC mathematica :eval never
myOutputFile=RunStan[stanExeFile, myOpt, StanVerbose -> False]
#+END_SRC
which must print:
#+BEGIN_EXAMPLE
/tmp/myOutputFile.csv
#+END_EXAMPLE

Now import this CSV file:
#+BEGIN_SRC mathematica :eval never
myResult = ImportStanResult[myOutputFile]
#+END_SRC
which prints:
#+BEGIN_EXAMPLE
     file: /tmp/myOutputFile.csv
     meta: lp__ , log_p__ , log_g__ 
parameter: alpha , beta , sigma 
#+END_EXAMPLE

As before, use:
#+BEGIN_SRC mathematica :eval never
GetStanData[myResult,"alpha"]
#+END_SRC

But now you will get a list of 1000 sample:
#+BEGIN_EXAMPLE
{2.03816, 0.90637, ..., ..., 1.22068, 1.66392}
#+END_EXAMPLE

Hopefully you can map any function, even =ListLinePlot= or =Histogram=. 

By example:

#+BEGIN_SRC mathematica :eval never
MapStanResult[Mean, myResult, "alpha"]
MapStanResult[Variance, myResult, "alpha"]
MapStanResult[Histogram, myResult, "alpha"]
#+END_SRC

prints:

#+BEGIN_EXAMPLE
2.0353
0.317084
#+END_EXAMPLE

[[file:figures/linRegHisto.png][file:./figures/linRegHisto.png]]


